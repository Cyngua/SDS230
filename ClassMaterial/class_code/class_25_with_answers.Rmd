---
title: "Class 25 notes and code"
output:
  pdf_document: default
  html_document: default
---





$\\$



<!--  Please run the code in the  R chunk below once. This will install some
packages and download data and images needed for these exercises.  -->

```{r message=FALSE, warning = FALSE, echo = FALSE, eval = FALSE}


SDS230::download_data("freshman-15.txt")

SDS230::download_data("IPED_salaries_2016.rda")


```




```{r setup, include=FALSE}

# install.packages("latex2exp")

library(latex2exp)
library(dplyr)
library(ggplot2)
library(tidyr)
library(plotly)

#options(scipen=999)


knitr::opts_chunk$set(echo = TRUE)

set.seed(123)

```





$\\$





## Overview

 * A few additional topics on the ANOVA
 * String manipulation


$\\$





## Part 1: A few additional topics on the ANOVA




Let's briefly discuss a few last topics on the analysis of variance. 





### Part 1.1: Examening unbalanced data


In an unbalanced data, there are different numbers of measured responses at the
different variable levels. When running an ANOVA on unbalanced data, one needs
to be careful because there are different ways to calculate the sum of squares
for the different factors, and this can lead to different results about which
factors are statistically significant. Let's examine this using the IPED faculty
salary data.


```{r}

load("IPED_salaries_2016.rda")

# Factor A: lecturer, assistant, associate, full professor
# Factor B: liberal arts vs research university 

IPED_3 <- IPED_salaries |>
  filter(rank_name %in% c("Lecturer", "Assistant", "Associate", "Full")) |>
  mutate(rank_name  = droplevels(rank_name)) |>
  filter(CARNEGIE %in% c(15, 31)) |>
 # na.omit() |>
  mutate(Inst_type = dplyr::recode(CARNEGIE, "31" = "Liberal arts", "15" = "Research extensive"))


# examine properties of the data 
table(IPED_3$Inst_type, IPED_3$rank_name)


```







$\\$







### Part 1.2: Examening unbalanced data - Type I sum of squares

In type I sum of squares, the sum of squares are calculated sequentially, where
first SSA is taken into account, and then SSB is consider. In particular:

* Factor A sum of squares is: SS(A) from fitting `lm(y ~ A)`
* Factor B sum of squares is: SS(B|A) from fitting `lm(y ~ A + B)` and subtracting this from SS(A)
* The interaction AB sum of squares is: SS(A, B, AB) - SS(A, B); i.e., the model is fit will `lm(y ~ A*B)` and then `SS(A, B)` is subtracted. 


```{r}

# Create a main effects and interaction model
fit_profs1 <- lm(salary_tot ~ Inst_type * rank_name, data = IPED_3)
fit_profs2 <- lm(salary_tot ~ rank_name * Inst_type, data = IPED_3)

anova(fit_profs1)
anova(fit_profs2)

```





$\\$




### Part 1.3: Examening unbalanced data - Type III sum of squares


In type III sum of squares, the sum of squares the full model is fit SS(A, B,
AB) and then the sum of squares for each factor is determined by taking the full
model SS(A, B, AB) and subtracting out the fit when a given factor is missing.

* Factor A sum of squares is: SS(A, B, AB) - SS(B, AB)
* Factor B sum of squares is: SS(A, B, AB) - SS(A, AB)
* The interaction AB sum of squares is: SS(A, B, AB) - SS(A, B)


```{r}

# type III sum of squares the order that variables are added does not matter
car::Anova(fit_profs1, type = "III")
car::Anova(fit_profs2, type = "III")

```




$\\$






### Part 1.4: Repeated measures ANOVA


In a repeated measures ANOVA, the same case/observational units are measured at
each factor level. For example, we might want to understand if people prefer
chocolate, butterscotch or caramel sauce on their ice cream. Rather than doing a
"between subjects" experiment, where we would have different people taste ice
cream with chocolate, butterscotch or caramel sauce, instead we can use a
"within subjects" design where the each person in the experiment tastes and
gives ratings for all three toppings.

To run a repeated measures ANOVA, one gives each observational unit a unique ID,
and then one treats this ID as another factor in the analysis; i.e., one runs a
factorial analysis where one of the factors is the observational unit ID.

An advantage of repeated measures ANOVA is similar to the advantage to running a
paired samples t-test, namely it can reduce a lot of the between observational
unit variability making it easier to see effects that are present. In fact,
running a repeated measures ANOVA with a factor that only has two levels is
equivalent to running a paired samples t-test. Let's explore this using the
example of Freshman gaining weight from homework 4.


```{r}

# load the data
freshman <- read.table("freshman-15.txt", header = TRUE) |>
  mutate(Subject = as.factor(Subject))


# run a paired t-test testing H0: mu_diff = 0 vs. HA: mu_diff > 0, 
#   where mu_diff = mu_end_i - mu_start_i 

t.test(freshman$Terminal.Weight, freshman$Initial.Weight, paired = TRUE)



# let's transform to put it in a long format
freshman_long <- tidyr::pivot_longer(freshman, 
                                     cols = c("Initial.Weight", "Terminal.Weight"),
                                     names_to = "time_period", 
                                     values_to = "weight")


# let's run run a repeated measures ANOVA 
# we have the same p-value, and F = t^2
summary(aov(weight ~ time_period + Subject, data = freshman_long))




```



If you want more practice running a repeated measures ANOVA, you can analyze the
popout attention data from homework 10, where you treat the participants in the
study as a factor in the analysis.




$\\$





## Part 2: String manipulation using stringr


The package stringr allows you to manipulate character strings. Many of the
functions in the stringr package are available in base R but the naming
conventions and arguments in stringr are more consistent which makes them easier
to use.


All stringr functions: 

* start with `str_`
* take a (vector of) string(s) as the first argument





$\\$






### Part 2.1: Base R and stringr


Let's start by putting a string in lower case using both base R and stringr. 


```{r}

library(stringr)


# base R
tolower("Hey")


# stringr
str_to_lower("STOP YELLING")




```





$\\$





### Part 2.2: Trimming and padding a string


We can trim and pad strings using `str_trim()` and `str_pad()`



```{r}



# trim a string 
str_trim("    What a mess      ")



# pad a string
str_pad("Let's make it messier", 50, "right")
str_pad(1:11, 3, pad = 0)   # useful for adding leading 0â€™s




```





$\\$





### Part 2.3: Extracting a piece of a string


```{r}


str_sub("What a mess", 6, 11)


fruits <- c("apple", "pineapple", "Pear", "orange",  "peach", "banana")
str_sub(fruits, 2, 4)


```





$\\$





### Part 2.4: Concatenating strings


We can concatenate strings using `str_c`. 

The base R function `paste()` and `paste0()` are also useful for this. 


```{r}


str_c("What", "a", "mess", sep = " ")

vec_words <- c("What", "a", "mess")
str_c(vec_words, collapse = " ")


```






$\\$






### Part 2.5: Download an article


Let's explore an article on the internet...



```{r}


# base_name <- "https://www.foxbusiness.com/politics/energy-groups-sue-biden-admin-fail# ing-hold-oil-gas-lease-sales-again"
# article_name <- "politics.html"
# download.file(base_name, article_name)


base_name <- "https://www.nytimes.com/2022/12/02/us/politics/rail-strike-biden.html"
article_name <- "politics.html"
download.file(base_name, article_name)

# viewer <- getOption("viewer")
# viewer(article_name)




```






$\\$





### Part 2.6: string length


We can get the length of a string using `str_length()`



```{r}


# length of a string
str_length("What a mess")
 

# size of the article in bytes
article_size <- file.info(article_name)$size    


# read the whole article as a single string
the_article <- readChar(article_name, article_size)


# length of the article as a string
str_length(the_article)     





```




$\\$





### Part 2.7: string replace all


We can replace the first occurrence of a string using `str_replace("String", "old", "new")`

We can replace all occurrences of a string using `str_replace_all()`


```{r}


# replace an occurrence of a substring
str_replace("String", "old", "new")


# replace all occurrences of a string
article2  <- str_replace_all(the_article,  "Biden", "Sleepy Joe")

write(article2, "sleepy_article.html")

#viewer("sleepy_article.html")



```




$\\$





### Part 2.8: String split


We can split a string into a list of strings using `str_split("String",  "split pattern")`



```{r}

# split up a string to a vector of strings
list_of_strings <- str_split("What a mess",  " ")
vector_of_strings <- unlist(list_of_strings)
vector_of_strings[3]


# split up all the words in the article into a vector
article_vec <- unlist(str_split(the_article, " "))


```




$\\$





### Part 2.9: Extracting strings


We can extract strings using `str_extract("String", "pattern")`


```{r}


# extract the word apple from our list of fruits
str_extract(fruits,  "apple")



```





$\\$





### Part 2.10: Detecting a string


We can detect with a substring exists in a string using `str_detect("String", "pattern")`



```{r}


# detect words that contain apple from our list of fruits
str_detect(fruits,  "apple")

# can you tell how many times Biden was mentioned in the article? 
sum(str_detect(article_vec, "Biden"))


```





$\\$








## Part 3: Regular expressions


We can use regular expressions to do a lot more complex string matching!




$\\$





### Part 3.1: Start and end of strings

Using regular expression we can match the start and end of words using: 

* Match the start of a string with ^
* Match the end of a string with $
* [Aa] detects a lower or upper case A



```{r start_end}

# detect all fruits that end with e
str_detect(fruits, "e$")


# detect all fruits that start with lower or upper case P
str_detect(fruits, "^[Pp]")


```





$\\$





### Part 3.2: Matching characters 


Using regular expression match characters using: 


* Match any character with .
* Match 0 or more characters with *
* Match 1 or more characters with +



```{r any_characater}

# detect "mess", "mass", and "miss" from the following string
mss_strings <- c("mess", "best", "mass", "kiss", "miss")
str_detect(mss_strings, "m.ss")


# detect all the strings from the xz_string
xz_strings <- c("xz", "xyz", "xyyz", "xyyyz")   
str_detect(xz_strings , "xy*z")


# detect all but the first string from the xz_string
str_detect(xz_strings, "xy+z")



```




$\\$





### Part 3.3: Matching anything in a range

* [ ] means match anything in the range inside the braces 
* If the ^ appears inside square braces it means not


```{r range_detect}

# detect all fruits that start with a vowel
str_detect(fruits, "^[a-o]")

# detect all these strings
ch_strings <- c("chimp", "champion", "chomp")
str_detect(ch_strings, "ch[aio]mp")


```





$\\$




### Part 3.4: Detecting repeats


* {num} means repeat the preceding sequence num times
* () groups things together, useful in combination with {}

```{r repeats}

# detect all fruits with an in them 
str_detect(fruits, "(an){1,}")

# detect all fruits with anan in them 
str_detect(fruits, "(an){2}")


```





$\\$





### Part 3.5: Example - extracting phone numbers

Can you extract all the phone numbers from these strings? 


```{r phone_numbers}

input_strings <- c(
	"apple", 
  	"219 733 8965", 
  	"329-293-8753", 
  	"Work: 579-499-7527",
	"Home: 543.355.3679"
)

phone_expression <- "([2-9][0-9]{2})[- .]([0-9]{3})[- .]([0-9]{4})"

str_extract(input_strings, phone_expression)



```



$\\$





### Part 3.6: Escape sequences


In regular expressions a period (.) means any character. So how can you detect if a period is in a string? 

Escape sequences in R start with two slashes \\ and cause the next character to be treated literally rather than as a special character
To match a period we use   `\\.`            [.] also works
To match a `$` symbol we use  `\\$`



```{r escape_sequences}

# Extract the amounts of money and dollar sign from this string  (use str_extract_all) 
the_string  <-  c("Constantin has $100 and Jeff has $0") 
str_extract_all(the_string, "\\$[0-9]{1,}")


```





$\\$





### Part 3.7: Special characters


Other special characters are also designated by using a double slash first
\\s   space
\\n   new line     or also   \\r
\\t   tab


```{r special_characters}

# get 6 characters prior to the end of a line in the_article
str_extract_all(the_article, ".{6}\\n") 


# extract all lines that have html tags at the end of the line
# i.e., that have </ > at the end of a line
end_tag <- str_extract_all(the_article, "</[A-z]{1,}>\\n")
str_replace(unlist(end_tag), "\\n", "")


```




